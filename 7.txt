I,II
1. Дефинирайте понятието сложност на алгоритъм, като попълните липсващите думи в текста.

Сложност на алгоритъм е [[1] - груба оценка на броя стъпки], които алгоритъмът ще направи в зависимост от [[2] - размера на входните данни]. Това е груба оценка, която се интересува от [[3] - порядъка на броя стъпки],
а не от [[4] - точния им брой].

2. Имате следния пример:

Трябва да намерите елемент в масив по даден ключ. Посочете сложността на алгоритъма в най-лошия, среден и най-добър случай:

Най-лош случай: [[1] - O(N)]

Среден случай: [[1] - O(N)]

Най-добър случай: [[2] - O(1)]

3. Дефинирайте понятието стабилност на сортирането.
 - Стабилност на сортирането - ако имаме два елемента които са равни в първоначалният масив, то във финалният те се срещат във същият ред като първоначалният масив.

Алгоритмите за стабилно сортиране използват следното правило: ако два елемента при сравнение са еднакви (като например двете петици), то тяхната първоначална подредба ще бъде съхранена, така че ако едната от тях е преди другата в 
началната подредба, то тя ще бъде първа и в крайния резултат.

4. Показани са означенията на типовете сложност на алгоритъм, посочете съответстващата му сложност, като изберете от падащия списък срещу всяко от означенията:

O(n3)        [[5] - кубична]

O(log(N))  [[2] - логаритмична]

O(N)         [[3] - линейна]

O(2n)        [[6] - експоненциална]

О(n2)        [[4] - квадратична]

O(1)          [[1] - константна]

O(N!)        [[6] - експоненциална]

5. Посочете за алгоритми с каква сложност се отнася следното твърдение:

Алгоритми с [[1] - константна, логаритмична и линейна] сложност са толкова бързи, че не можем да усетим забавяне, дори при относително голям размер на входните данни.


III,IV
1. Имате следния програмен фрагмент:
   private static int FindMaxElement(int[] array)
        {
            int max = int.MinValue;
            for (int i = 1; i < array.Length; i++)
            {
                if (array[i] > max)
                {
                    max = array[i];
                }
            }
            return max;
        }
Каква ще бъде сложността на алгоритъма и обяснете защо?
 - Ако имаме единичен цикъл от 1 до N, сложността му е линейна – O(N):

2. Имате следния програмен фрагмент:
   private static int FindInversions(int[] array)
        {
            int inversions = 0;
            for (int i = 1; i < array.Length - 1; i++)
            {
                for (int j = i + 1; j < array.Length; j++)
                {
                    if (array[i] > array[j])
                    {
                        inversions++;
                    }
                }
            }
            return inversions;
        }
Имате следния програмен фрагмент:
private static int FindInversions(int[] array)
        {
            int inversions = 0;
            for (int i = 1; i < array.Length - 1; i++)
            {
                for (int j = i + 1; j < array.Length; j++)
                {
                    if (array[i] > array[j])
                    {
                        inversions++;
                    }
                }
            }
            return inversions;
        }

Каква ще бъде сложността на алгоритъма и обяснете защо?
 - Ако имаме два вложени цикъла от 1 до N, сложността им е квадратична – O(N2).

3. Имате следния програмен фрагмент:
    long Sum(int n)
        {
            long sum = 0;
            for (int a = 1; a < n; a++)
            {
                for (int b = 0; b < n; b++)
                {
                    for (int c = 1; c < n; c++)
                    {
                        sum += a * b * c;
                    }
                }
            }
            return sum;
        }
Каква ще бъде сложността на алгоритъма и обяснете защо?
 - Ако имаме три вложени цикъла от 1 до N, сложността им е кубична – O(N3).

4. Имате следния програмен фрагмент:
   private static long Sum(int n, int m)
        {
            long sum = 0;
            for (int x = 1; x <= n; x++)
            {
                for (int y = 1; y <= m; y++)
                {
                    sum += x * y;
                }
            }
            return sum;
        }
Каква ще бъде сложността на алгоритъма и обяснете защо?
 - Ако имаме два вложени цикъла съответно от 1 до N и от 1 до M, сложността им е квадратична – O(N*М)

5. Целта на задачата е да можете да различавате видовете алгоритми. На картинките са показани два алгоритъма. 
Срещу всяка една от картинките трябва да попълните кой от видовете алгоритми е използван.

var collection = new int[] { 22, 13, 4, 8, 56, 16, 36, 12, 7 };
        for (int curr = index + 1; curr < collection.Lenght; curr++)
			{
            if (collection[curr] < collection[min])
	{
            min = curr;
	}
			}
int temp = collection[index];
collection[index] = collection[min];
collection[min] = temp;

Console.WriteLine(string.Join(" ", collection));
 - Алгоритъм за сортиране на елементите в масив. Използван е алгоритъма за сортиране чрез пряка селекция.


var collection = new int[] { 22, 13, 4, 8, 56, 16, 36, 12, 7 };
var key = int.Parse(Console.ReadLine());
var flag = false;
for (int index = 0; index < collection.Length; index++)
{
    if (collection[index].CompareTo(key) == 0)
    {
        flag = true;
    }
}
if (!flag)
{
    Console.WriteLine(-1);
}
 - Алгоритъм за търсене на елемент в масив. Използван е алгоритъма линейно търсене.

6. Целта на задачата е да можете да различавате видовете алгоритми. На картинките са показани два алгоритъма. 
Срещу всяка една от картинките трябва да попълните кой от видовете алгоритми е използван.

var list = Console.ReadLine().Split().Select(int.Parse).ToList();
for (int j = 0; j <= list.Count - 2; j++)
{
    for (int i = 0; i <= list.Count - 2; i++)
    {
        if (list[i] > list[i + 1])
        {
            int temp = list[i];
            list[i] = list[i + 1];
            list[i + 1] = temp;
        }
    }
}
 - Алгоритъм за сортиране на елементите в масив. Използван е алгоритъма за сортиране чрез метода на мехурчето.


var list = Console.ReadLine().Split().Select(int.Parse).ToArray();
int start = 0, end = list.Length;
int key = 5;
var flag = false;
while (end >= start)
{
    int mid = (start + end) / 2;
    if (list[mid] < key)
        start = mid + 1;
    else if (list[mid] > key)
        end = mid - 1;
    else
    {
        flag = true;
        Console.WriteLine(mid);
        break;
    }
}
if(!flag)
    Console.WriteLine(-1);
- Алгоритъм за търсене на елемент в масив. Използван е алгоритъма двоично търсене.


V
1. Зелено
Това е визуализация на един от алгоритмите за сортиране. За този алгоритъм важи следното правило: 
Взима първият елемент на масива (29) и го сравнява със следващия (10). В случая следващия елемент е по-малък 
и стойностите се разменят. След това сравнява вторият елемент, който вече е (29) със следващия (14) и тъй като 14 < 29 
отново ги разменя. Алгоритъма разменя стойностите, само ако има нужда от това. Ако следващия елемент (напр. 37) е по-голям 
от предходния (29) тогава елементите няма да се разменят и сравняването ще продължи вече с новото по-голямо число (37) и следващият 
елемент (14). Продължава така, докато не подреди елементите в масива. 

 - Сортиране на елементите чрез метода на мехурчето.

2. Червено
Това е визуализация на един от алгоритмите за сортиране. За този алгоритъм важи следното правило: 
Взема първият елемент в масива (29) и го сравнява със всеки следващ (10, 14, 37...) докато не намери най-малкия елемент (2). Разменя намереният най-малък елемент (2) с първоначално избрания (29). Тези стъпки се повтарят докато елементите в масива не се сортират.
Посочете кой от видовете алгоритми е използван:

- Сортиране на елементите чрез пряка селекция.

3. Жълто
Това е визуализация на един от алгоритмите за сортиране. За този алгоритъм важи следното правило: 
Масивът с несортирани елементи се разделя на две части: в едната част са сортираните елементи, в другата част са несортираните елементи. В случая числото 29 се предполага, че е в сортираната част, а числата от 10 до 6 - в несортираната. При всяка стъпка се взема първият елемент от несортираните елементи (в случая числото 10) сравнява го с предходните елементи и се поставя на правилната позиция в сортираната част на масива (в случая преди числото 29). На следващата стъпка първото число от несортирания масив е числото 14, взема това число и го поставя на правилната позиция в сортирания масив (между числата 10 и 29). Алгоритъма продължава докато елементите в несортираната част на масива се изчерпят.
Посочете кой от видовете алгоритми е използван:

- Сортиране на елементите чрез вмъкване.


VI
1. Дайте пример с C# код, за метод който да сортира  елементите от списъка List<int> list = new List<int>() { 12, 8, 10, 2, 9, 6, 1}; посредством алгоритъма за сортиране  чрез метода на мехурчето.
 - public static void BubbleSortWithFor(List<int> list)
        {
            for (int j = 0; j <= list.Count - 2; j++)
            {
                for (int i = 0; i <= list.Count - 2; i++)
                {
                    if (list[i] > list[i + 1])
                    {
                        Swap(list, i, i + 1);
                    }
                }
            }
        }
private static void Swap(List<int> list, int index, int min)
        {
            int temp = list[index];
            list[index] = list[min];
            list[min] = temp;
        }

2. Дайте пример с C# код, за метод който да сортира  елементите от списъка List<int> list = new List<int>() { 12, 8, 10, 2, 9, 6, 1}; посредством алгоритъма за сортиране  чрез вмъкване.
 - public static void InsertionSort(List<int> list)
        {
            for (int i = 1; i < list.Count; ++i)
            {
                int key = list[i];
                int j = i - 1;

                // Move elements of arr[0..i-1], 
                // that are greater than key, 
                // to one position ahead of 
                // their current position 
                while (j >= 0 && list[j] > key)
                {
                    list[j + 1] = list[j];
                    j = j - 1;
                }
                list[j + 1] = key;
            }
        }
private static void Swap(List<int> list, int index, int min)
        {
            int temp = list[index];
            list[index] = list[min];
            list[min] = temp;
        }


3. Дайте пример с C# код, за метод който да сортира  елементите от списъка List<int> list = new List<int>() { 12, 8, 10, 2, 9, 6, 1}; посредством алгоритъма за сортиране  чрез пряка селекция. 
 - public static void SelectionSort(List<int> list)
        {
            for (int index = 0; index < list.Count; index++)
            {
                int min = index;
                for (int current = index + 1; current < list.Count; current++)
                {
                    if(list[current] < list[min])
                    {
                        min = current;
                    }
                }

                Swap(list, index, min);
            }
            
        }

private static void Swap(List<int> list, int index, int min)

        {

            int temp = list[index];

            list[index] = list[min];

            list[min] = temp;

        }


VII
1. Имате следният програмен фрагмент, който трябва да сортира елементите в подаден списък. В кода има грешка и не работи правилно. 
При примерен вход: 36 15 1 7 20 8 24

Програмата извежда като резултат следното: 1 1 1 7 8 8 24

А трябва да изведе сортираните елементи: 1 7 8 15 20 24 36

var list = Console.ReadLine().Split().Select(int.Parse).ToList();
            for (int j = 0 j <= list.Count - 2; j++)
            {
                for (int i = 0; i <= list.Count - 2; i++)
                {
                    if (list[i] > list[i + 1])
                    {
                        list[i] = list[i + 1];
                        list[i + 1] = list[i];
                    }
                }
            }
            Console.WriteLine(string.Join(" ", list));

Вашата задача е да откриете грешката, да я поправите и да запишете в полето вече правилно работещ код.

 - var list = Console.ReadLine().Split().Select(int.Parse).ToList();
for (int j = 0; j <= list.Count - 2; j++)//2т
{
    for (int i = 0; i <= list.Count - 2; i++)
    {
        if (list[i] > list[i + 1])
        {
            int temp = list[i];//2т
            list[i] = list[i+1];
            list[i+1] = temp;//2т
        }
    }
}
Console.WriteLine(string.Join(" ", list));


2. Имате следният програмен фрагмент, който трябва да сортира елементите в подаден списък. В кода има грешка и не работи правилно. 
При примерен вход: 36 15 1 7 20 8 24

Програмата извежда като резултат следното: 1 1 1 7 8 8 24

А трябва да изведе сортираните елементи: 1 7 8 15 20 24 36

var collection = Console.ReadLine().Split().Select(int.Parse).ToList();
            for (int index = 0; index < collection.Count; index++)
            {
                int min = index;
                for (int curr = index + 1; curr < collection.Count; curr++)
                {
                    if (collection[curr] > collection[min])
                    {
                        min = curr;
                    }
                }
                collection[index] = collection[min];
                collection[min] = collection[index];
            }
            Console.WriteLine(string.Join(" ", collection));

Вашата задача е да откриете грешката, да я поправите и да запишете в полето вече правилно работещ код.

 - var collection = Console.ReadLine().Split().Select(int.Parse).ToList();
            for (int index = 0; index < collection.Count; index++)
            {
                int min = index;
                for (int curr = index + 1; curr < collection.Count; curr++)
                {
                    if (collection[curr] < collection[min]) //2т
                    {
                        min = curr;
                    }
                }               
                int temp = collection[index]; //2т
                collection[index] = collection[min];
                collection[min] = temp; //2т
            }
            Console.WriteLine(string.Join(" ", collection));


VIII,IX,X
1. Посочете вярното за следното твърдение:
[[1] - Enqueue] – добавя елемент в края на опашката

2. Имате даден следният псевдо код на алгоритъм за сортиране. Посочете кой алгоритъм за сортиране е използван:
do
    swapped = false
    for i = 1 to indexOfLastUnsortedelement-1
      if leftElement > rightElement
        swap(leftElement, rightElement)
        swapped = true; ++swapCounter
while swapped

Това е псевдо код за имплементация на алгоритъм за сортиране чрез [[1] - метода на мехурчето]


3. Имате даден следният псевдо код на алгоритъм за сортиране. Посочете кой алгоритъм за сортиране е използван:
mark first element as sorted
for each unsorted element X
    'extract' the element X
    for j = lastSortedIndex down to 0
      if current element j > X
        move sorted element to the right by 1
    break loop and insert X here

Това е псевдо код за имплементация на алгоритъм за сортиране чрез [[2] - вмъкване]

3. Имате даден следният псевдо код на алгоритъм за сортиране. Посочете кой алгоритъм за сортиране е използван:
repeat (numOfElements - 1) times
    set the first unsorted element as the minimum
    for each of the unsorted elements
       if element < current<imi,u,
         set element as new minimum
    swap minimum with first unsorted position

Това е псевдо код за имплементация на алгоритъм за сортиране чрез [[3] - пряка селекция]

4. public class CircularQueue<T>
{
    private const int DefaultCapacity = 4;
    public int Count { get; private set; }
    public CircularQueue(int capacity = DefaultCapacity) { }
    public void Enqueue(T element) { }
    public T Dequeue() { }
    public T[] ToArray() { }
}

На картинката е показана част от имплементацията на линейната структура от данни опашка. Посочете коя имплементация е използвана:

 - Статична имплементация на опашка

5. class CustomQueue<T> 
{
    private class QueueNode<T>
    {
        public T value { get; private set; }
        public QueueNode<T> NextNode { get; set; }
        public QueueNode<T> PrevNode { get; set; }
        public QueueNode(T value)
        {
            this.Value = value;
        }


    }

    private QueueNode<T> head;
    private QueueNode<T> tail;
    public int Count { get; private set; }
}

На картинката е показана част от имплементацията на линейната структура от данни опашка. Посочете коя имплементация е използвана:

 - Динамична имплементация на опашка

6. Много разклонено
На картинката е показана илюстрация на един от видовете алгоритми за сортиране. Посочете кой е той:

- Сортиране чрез сливане (Merge sort)

7. 3 реда
 На картинката е показана илюстрация на един от видовете алгоритми за сортиране. Посочете кой е той:

 - Сортиране чрез броене (Counting sort)



XI,XII,XIII
1. Имате дадени твърдения. Вие трябва да можете да различавате и сравнявате видовете структури от данни. Срещу всяко едно от тези твърдения трябва да зададете правилната структура от данни за която то се отнася.

За добавяне на елемент в структурата от данни използва операцията Push(T). [[1] - Стек]

Можем да обходим елементите в структура от данни тип опашка с  помощта на for-цикъл. [[3] - Твърдението не е вярно]

За премахване на елемент от структурата от данни използва операцията Dequeue(). [[2] - Опашка]

За премахване на елемент от структурата от данни използва операцията Pop(). [[1] - Стек]

Структура от данни, която има поведението първи влязъл първи излязъл. [[2] - Опашка]

Можем да достъп елемент от структурата от данни стек, като използваме операцията Peek(index) неговия индекс. [[3] - Твърдението не е вярно]

Структура от данни, която има поведението последен влязъл първи излязъл. [[1] - Стек]

За добавяне на елемент в структурата от данни използва операцията Enqueue(T). [[2] - Опашка]


2. Дайте пример за това къде можете да срещнете поведението на структурата от данни опашка във вашето ежедневие. И обяснете защо.
 - Пример : Например опашка от хора, чакащи на каса за билети. Опашката има начало и край. Новодошлите хора застават последни на опашката и изчакват докато постепенно се придвижат към началото. Когато стигнат до самото начало на опашката си купуват билет и напускат опашката. 

Пример 2: Други примери за опашка са документи, чакащи да бъдат отпечатани.

Пример 3: Ескалатор превозващ хора. По този начин опашката изпълнява функцията на буфер.

Защото: Структурата от данни опашка изпълнява условието „първият влязъл първи излиза“ (FIFO: First-In-First-Out). Това означава, че след като е добавен един елемент в края на опашката, той ще може да бъде извлечен (премахнат) 
единствено след като бъдат премахнати всички елементи преди него в реда, в който са добавени.


3. Дайте пример за това къде можете да срещнете поведението на структурата от данни стек във вашето ежедневие. И обяснете защо.
 - Пример 1 : Работната памет на програмата (стек) - Примитивните типове данни (числа, char, bool) се наричат стойностни типове, защото пазят непосредствено своята стойност в стека за изпълнение на програмата. 

Стекът е често срещана и използвана структура от данни. Стек се използва и вътрешно от C# виртуалната машина за съхранение на променливите в програмата и параметрите при извикване на метод.

Например една променлива, декларирана в метода Main() на програмата се пази в стека докато програмата завърши изпълнението на този метод, т.е. докато не завърши.

Пример 2: Куп с чинии

Пример 3: Куп с книги

Защото: Стекът има поведение последен влязъл пръв излязъл. 

4. Разработвате ново приложение за оптимизиране на процесите в работата на призводствено предприятие. Трябва да приложите структура от данни, която да работи като „буфер“ срещу надхвърляне на капацитета. Когато сме в рамките на призводствения капацитет, артикулите в 
буфера трябва да се обработят в реда, в който се добавят. Обяснете коя структура от данни трябва да използвате защо бихте използвали точно нея, за да приложите такъв буфер?
 - В опашката, артикулите се обработват в реда, в който са добавени. В частност, артикулите се добавят в края на опашката и се премахват от началото. Това е общоизвестно като first-in, first-out (FIFO) обработване.

5. Обяснете какво прави методът Dequeue()?
 - премахва и връща елемента от началото на опашката

6. Обяснете какво прави методът Enqueue(T)?
 - добавя елемент в края на опашката



XIV,XV,XVI
1. Ако имате следната последователност от числа: "12, 14, 24, 28, 29, 32, 36, 40, 41" и трябва да напишете алгоритъм, който да намери елемент от този списък, например числото 36. 

Като използвате алгоритъма за двоично търсене обяснете последователността от стъпки, които трябва да се изпълнят за да намерите търсеното число. 

А какво ще се случи, ако търсеното число не е в списъка?
 - Алгоритъма за двоично търсене работи само и единствено със сортирани елементи, като разделя масива на две части. Ако търсеното число съвпада със средния елемент,тогава алгоритъма връща индекса на средния елемент. 

Ако търсеното число е по-голямо от средния елемент, тогава  търсеното число стои в дясната половина на масива. Тогава разделяме дясната половина отново на две части и сравняваме със средния елемент. 

Ако търсеното число е по-малко от средния елемент тогава търсим в лявата половина на масива, като отново я разделяме на две части и сравняваме със средния елемент.

Алгоритъмът се повтаря докато открием търсения елемент.

Ако x не съвпада с нито един от елементите, връщаме -1.


2. Ако имате следната последователност от числа: "15, 85, 34, 12, 0, -9, 14, 63, 7, 32" и трябва да напишете алгоритъм, който да намери елемент от този списък, например числото 34. 

Като използвате алгоритъма за линейно търсене обяснете последователността от стъпки, които трябва да се изпълнят за да намерите търсеното число. 

А какво ще се случи, ако търсеното число не е в списъка?

 - Линейното търсене е прост подход за намиране на елемент в списък.

Започваме от най-левия елемент на масива и едно по едно сравняваме търсеното число (х) с всеки елемент на масива.

Ако x съвпада с елемент от масива, връщаме индекса, в случая числото 34 е на индекс 2 и алгоритъма трябва да върне числото 2 като резултат.

Ако x не съвпада с нито един от елементите, връщаме -1.


3. Да кажем, че играем на игра, в която трябва да познаете числото. Имате списък с числа от  1 до 20 включително подредени във възходящ ред. Решете задачата, като намерите кое е търсеното число и използвания алгоритъм за търсене на числото. 

Намислям си число и ти предполагаш, че числото е 11. Аз ти казвам, че моето число е по-малко. 

Търсиш в числата между 1 и 10. Предполагаш, че моето число е 5. Аз ти казвам, че моето число е по-малко.

Търсиш в числата между 1 и 4. Предполагаш, че моето число е 2. Аз ти казвам, че моето число е по-голямо.

Позна ли кое е моето число? [[1] - Търсеното число е 3]

Кой алгоритъм за търсене използва? [[7] - Двоично търсене]


4. Имате зададени твърдения за два алгоритъма за търсене - двоично търсене и интерполационно търсене. По зададените твърдения и характеристики трябва да сравните двата алгоритъма и да зададете коя от тях към кой от алгоритмите се отнася:

Стойностите в масива трябва да са сортирани и равномерно разпределени. [[1] - Интерполационно търсене]

Работи във времева сложност O(log n). [[2] - Двоично търсене]

Ако ключът е по-малък от средния елемент, тогава ключът може да лежи само в левия подмасив. [[3] - Отнася се и за двата алгоритъма]

Работи във времева сложност O(log(log n)). [[1] - Интерполационно търсене] 

Ако ключът е по-голям от средния елемент, тогава ключът може да лежи само в десния подмасив. [[3] - Отнася се и за двата алгоритъма]

Може да се оцени позицията на стойността на ключа в масива,като се вземат предвид най-малкият и най-големият елемент в масива и дължината на масива. [[1] - Интерполационно търсене]

Оценява средната позиция за масива и сравнява този елемент с желания ключ. [[1] - Интерполационно търсене]

Ако ключът съвпада със средния елемент, върнете средното местоположение. [[3] - Отнася се и за двата алгоритъма]


5. Имате зададени твърдения за два алгоритъма за търсене - двоично търсене и линейно търсене. По зададените твърдения и характеристики трябва да сравните двата алгоритъма и да зададете коя от тях към кой от алгоритмите се отнася:

Стойностите в масива трябва да са сортирани. [[2] - Двоично търсене]

Работи във времева сложност O(log n). [[2] - Двоично търсене]

Ако ключът е по-малък от средния елемент, тогава ключът може да лежи само в левия подмасив. [[2] - Двоично търсене]

Работи във времева сложност O(log(log n)). [[1] - Линейно търсене] 

Ако ключът е по-голям от средния елемент, тогава ключът може да лежи само в десния подмасив. [[2] - Двоично търсене]

Стойностите в масива не е задължително да са сортирани. [[1] - Линейно търсене]

Започва винаги от началото на масива. [[1] - Линейно търсене]

Ако ключът съвпада със средния елемент, върнете средното местоположение. [[2] - Двоично търсене]

Започва търсенето от средата на масива. [[2] - Двоично търсене]


XVII
1. Имате даден следният програмен фрагмент. Свържете правилно липсващите части от кода.  

          int low = 0;
            int high = sortedArray.Length - 1;
            while (sortedArray[[1] - [low]] <= key && sortedArray[[2] - [high]] >= key)
            {
                int mid = low + ((key - sortedArray[low]) * (high - low))
                  / (sortedArray[high] - sortedArray[low]);
                if ([[3] - sortedArray[mid] < key])
                    low = mid + 1;
                else if ([[4] - sortedArray[mid] > key])
                    high = mid - 1;
                else
                    return mid;
            }
            if ([[5] - sortedArray[low] == key]) return low;
            else return -1;


2. Изчислете какъв ще бъде отговорът на следния пример:

През 2013 ООН има 193 страни членки. Ако имената на тези страни са сортирани по азбучен ред в масив, колко имена трябва да провери двоичното търсене, за да намери конкретно име в масива в най-лошия случай?

[[1] - Не повече от 8.]


XVIII,XIX,XX,XI,XXII
1. Имате даден програмен фрамент от код написан на C#.
 Съставете програма, която намира най-дългата последователност от равни числа в даден списък от цели числа List<int>   и отпечатва като резултат тази най-дълга последователност. Ако няколко поредици имат същата най-дълга дължина, върнете най-лявата от тях.

 -  static void LongestSequenceEqualNumbers()
        {
            //List<int> nums = Console.ReadLine().Split().ToList(); //2т
            List<int> nums = Console.ReadLine().Split().Select(int.Parse).ToList();

            //int bestStart = 0 //2т
            int bestStart = 0;
            int bestLength = 1;
            int currentLength = 1;
            int index = 0;
            int first = nums[index];

            for (int i = 1; i < nums.Count; i++)
            {
                if (first == nums[i])
                {
                    currentLength++;
                    if (currentLength > bestLength)
                    {
                        bestLength = currentLength;
                        //bestStart = index; //2т
                        bestStart = index;
                    }
                }
                else
                {
                    first = nums[i];
                    index = i;
                    //currentLength = 1; //2т
                    currentLength = 1;
                }
            }

            for (int i = bestStart; i < bestStart + bestLength; i++)
            {
                Console.Write($"{nums[i]} ");
            }
        }

2. Запазете историята на браузъра. Ще получите възможни команди:
URL – отваря дадената страница
back – връща към предната страница
exit – спира програмата

 - За задачата не е използвана правилната структура от данни. Трябва да се използва структурата от данни Stack<int> и съответстващите ѝ методи за добавяне и премахване на елементите. //2т

Stack<string> pages = new Stack<string>();//2т

            string command = Console.ReadLine();
            string previous = null;

            while (!"exit".Equals(command))
            {
                
                if (command.Equals("back"))
                {
                    if (pages.Count != 0)
                    {
                        Console.WriteLine(pages.Pop());//2т
                    }
                    previous = null;
                }
                else
                {
                    if (previous != null)
                    {
                        pages.Push(previous);//2Т
                    }

                    previous = command;
                }

                command = Console.ReadLine();
            }
        }

3. Имате следният програмен фрагмент, който трябва да сортира елементите в подаден списък. В кода има грешка и не работи правилно. 
При примерен вход: 36 15 1 7 20 8 24

Програмата извежда като резултат следното: 1 1 1 7 8 8 24

А трябва да изведе сортираните елементи: 1 7 8 15 20 24 36

var list = Console.ReadLine().Split().Select(int.Parse).ToList();
            for (int i = 0; i <= list.Count - 2; i++)
            {
                for (int i = 0; i <= list.Count - 2; i++)
                {
                    if (list[i] < list[i + 1])
                    {
                        list[i] = list[i + 1];
                        list[i + 1] = list[i];
                    }
                }
            }
            Console.WriteLine(string.Join(" ", list));

Вашата задача е да откриете грешката, да я поправите и да запишете в полето вече правилно работещ код.

 - var list = Console.ReadLine().Split().Select(int.Parse).ToList();
for (int j = 0; j <= list.Count - 2; j++)//2т
{
    for (int i = 0; i <= list.Count - 2; i++)
    {
        if (list[i] > list[i + 1])//2т
        {
            int temp = list[i];//2т
            list[i] = list[i+1];
            list[i+1] = temp;//2т
        }
    }
}
Console.WriteLine(string.Join(" ", list));


4. Имате следният програмен фрагмент, който трябва да сортира елементите в подаден списък. В кода има грешка и не работи правилно. 
При примерен вход: 36 15 1 7 20 8 24

Програмата извежда като резултат следното: 1 1 1 7 8 8 24

А трябва да изведе сортираните елементи: 1 7 8 15 20 24 36

var collection = Console.Readline().Split().Select(int.Parse).ToList();
            for (int index = 0; index < collection.Count; index++)
            {
                int min = index;
                for (int curr = index + 1; curr < collection.Count; curr++)
                {
                    if (collection[curr] > collection[min])
                    {
                        min = curr;
                    }
                }
                collection[index] = collection[min];
                collection[min] = collection[index];
            }
            Console.WriteLine(string.Join(" ", collection));

Вашата задача е да откриете грешката, да я поправите и да запишете в полето вече правилно работещ код.

 - var collection = Console.ReadLine().Split().Select(int.Parse).ToList(); //2т
            for (int index = 0; index < collection.Count; index++)
            {
                int min = index;
                for (int curr = index + 1; curr < collection.Count; curr++)
                {
                    if (collection[curr] < collection[min])//2т
                    {
                        min = curr;
                    }
                }               
                int temp = collection[index]; //2т
                collection[index] = collection[min];
                collection[min] = temp; //2т
            }
            Console.WriteLine(string.Join(" ", collection));


5. Даден е аритметичен израз със скоби (може и вложени).
Цел: извличане на всички под-изрази в скоби
Примерен вход: 
1 + (2 - (2 + 3) * 4 / (3 + 1)) * 5

Изход:

(2 + 3)

(3 + 1)

(2 - (2 + 3) * 4 / (3 + 1))

Имате следният програмен фрагмент. 
В кода има грешка и не работи правилно.
static void Main(string[] args)
        {
            Queue<int> indexes = new Queue<int>(); 
            string expression = Console.ReadLine(); 
            for (int i = 0; i < expression.Length; i++)
            {
                if (expression[i] == '(')
                {
                    indexes.Enqueue(i);
                }
                else if (expression[i] == ')')
                {
                    int startIndex = indexes.Dequeue();
                    int length = i - startIndex + 1; 
                    string substr = expression.Substring(startIndex, length);
                      Console.WriteLine(substr);
                }
            }
        }

Вашата задача е да анализирате този фрагмент от код и да идентифицирате и поправите правилно грешките в написания програмен код, така че да реши поставената задача. Да допълните кода, ако и когато това е необходимо.

В полето за въвеждане записвате:

1. Вашият анализ на грешката и това как може да бъде поправено. 

2. Редактиран и правилно работещ код.

 - За задачата не е използвана правилната структура от данни. Трябва да се използва структурата от данни Stack<int> и съответстващите ѝ методи за добавяне и премахване на елементите. //2т

Stack<int> indexes = new Stack<int>();//2т
            string expression = Console.ReadLine();
            for (int i = 0; i < expression.Length; i++)
            {
                if (expression[i] == '(')
                {
                    indexes.Push(i);//2т
                }
                else if (expression[i] == ')')
                {
                    int startIndex = indexes.Pop();//2т
                    int length = i - startIndex + 1;

                    string substr = expression.Substring(startIndex, length);
                    Console.WriteLine(substr);
                }

            }

6. Този фрагмент е част от имплементацията на линейната структура от данни стек - премахване на елемент от стек. В кода има грешка! Вашата задача е да анализирате този фрагмент от код и да идентифицирате и поправите правилно грешките в написания програмен код, така че да реши поставената задача. Да допълните кода, ако и когато това е необходимо.
 - Грешката в кода е, че методът Pop(int index) получава цяло число, което вътре в метода се използва за намиране на елемента в масива и премахването на този елемент. По дефиниция линейната структура стек не работи така. Правилото за работа със стек е "първи влиза - първи излиза". Нямаме право да достъпваме елементите по индекс, освен само и единствено за четене. Когато правим имплементацията за премахване на елемент от стек винаги премахваме последния елемент - в случая трябва да използваме броя на елементите (Count) на мястото на параметъра Index, за да премахнем последния елемент от масива в класа. И самия метод Pop() не трябва да приема параметър.//2т

public T Pop()//2т
        {
            if (this.Count == 0)
            {
                throw new InvalidOperationException("Empty stack");
            }
            this.Count--;//2т
            T element = this.items[this.Count];//2т

            T[] temp = new T[this.items.Length];
            for (int i = 0; i < this.Count; i++)
            {
                temp[i] = this.items[i];
            }

            this.items = temp;
            return element;
        }