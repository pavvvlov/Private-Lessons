I.
1. Избройте видовете имплементации на линейни структури от данни.
 - Чрез разтеглив масив (статично)

Чрез свързан списък (nodes) (Динамично)

2. Избройте какви линейни структури от данни познавате?
 - Списъци, стекове и опашки

3. Избройте поне четири операции (методи), които можете да прилагате върху списък.
 - Add(T item)

Remove(T item)

RemoveAt(int index)

Sort()

ToArray()

4. Посочете за коя от колекциите в С# е вярно следното твърдение: „Последователно съхранение на елементите и потребителя има пълен контрол върху реда на елементите“?
 - List
 
5. Посочете кое от следните твърдения е вярно за разтеглив масив?
 - структура от данни, която е масив по своята същност, но за разлика от обикновеният масив може да променя размера си

II.
1. Имате следния фрагмент код:
class CustomArrayList
    {
        private object[] arr;
        private int count;

        public int Count { get { return count; } }

        private static readonly int INITIAL_CAPACITY = 4;

        public CustomArrayList() 
        {
            arr = new object[INITIAL_CAPACITY];
            count = 0;
        }
	}
Каква реализация на списъчна структура от данни представлява този код? Обобщете отговора си и напишете кратко обяснение, защо?

 - Статична имплементация на списък. Защото в класа е деклариран масив (object[] arr), който ще съхранява елементите в списъка. Има първоначален капацитет, който при запълване на масива, ще се удвои и в паметта ще се задели двойно по-голям капацитет. По този начин преоразмеряваме (разтегляме) масива и можем да добавяме още елементи в списъка. 

2. Имате следния фрагмент код:
   class CustomList
    {
        private object element;
        private Node next;

        public Node(object element, Node prevNode) 
        {
            this.Element = element;
            prevNode.Next = this;
        }

        public Node(object element) 
        {
            this.Element = element;
        }
	}
Каква реализация на списъчна структура от данни представлява този код? Обобщете отговора си и напишете кратко обяснение, защо?
 - Динамична имплементация на списък. Защото в класа е деклариран друг клас, наречен Node(възел). Този клас ни служи като елемент (обект), който да пази стойността на елемента, който добавяме в списъка (пропъртито Element) и също така съдържа и елемент отново от тип Node, който ще служи като указател към следващия елемент в списъка. По този начин 
реализираме свързан списък или използваме динамична имплементация, за да създадем наша собствена списъчна структура от данни.

3. Имате следния фрагмент код:
   private class Node<T>
        {
            public T Value { get; set; }
            public Node<T> PrevNode { get; private set; }
            public Node(T Value, Node<T> prev = null)
            {
                this.Value = Value;
                this.PrevNode = prev;
            }
        }

        private Node<T> firstNode;
        public int Count { get; private set; }
Каква реализация на списъчна структура от данни представлява този код? Обобщете отговора си и напишете кратко обяснение, защо?

 - Динамична имплементация на стек. Защото в класа е деклариран друг клас, наречен Node(възел). Този клас ни служи като елемент (обект), който да пази стойността на елемента, който добавяме в стека(пропъртито Value) и също така съдържа и елемент отново от тип Node (PrevNode), който ще служи като указател към следващия постъпил елемент в стека. 
В този случай винаги имаме достъп до първия нод (възел) в стека, защото правилото при стека е първи влиза - първи излиза. По този начин реализираме свързан стек или използваме динамична имплементация, за да създадем наша собствена списъчна структура от данни - стек.

4. Имате дадени следните твърдения: 

Губим възможността за произволен достъп. Няма начин, по който да индексираме k-тия елемент, без да минем през всички k-1 предходни. [[2] - Динамична имплементация]

Реализация на списък чрез масив, който автоматично увеличава размера си при нужда. [[1] - Статична имплементация]

Операциите добавяне и премахване от вътрешността  на списъка изискват пренареждане на елементите. [[1] - Статична имплементация]

Операциите добавяне и премахване от вътрешността  на списъка е бърза операция. [[2] - Динамична имплементация]

Търсенето на елементите в него е сравнително бърза операция. [[1] - Статична имплементация]

При често добавяне и премахване (особено при голям брой елементи) това може да доведе до ниска производителност. [[1] - Статична имплементация]

Можем да поддържаме паметта точно колкото ни трябва като сложността на добавяне си остава. [[2] - Динамична имплементация]

Елементите съдържат само конкретния обект. [[1] - Статична имплементация]

Всеки елемент съдържа променлива и указател, сочещ към следващия елемент. [[2] - Динамична имплементация]


III.
1. Даден е следния програмен фрагмент:

class CustomList
    {
        private class Node
        {
            private object element;
            private Node next;
            public Node(object element, Node prevNode)
            {
                this.Element = element;
                prevNode.Next = this;
            }
            public Node(object element)
            {
                this.Element = element;
            }
            public object Element
            {
                get { return this.element; }
                set { this.element = value; }
            }
            public Node Next
            {
                get { return this.next; }
                set { this.next = value; }
            }
        }
        //полета
        //глава(начало) на списъка
        private Node head;
        //опашка(край) на списъка
        private Node tail;
        //броят на елементите в свързания списък
        private int count;
        public int Count
        {
            get { return this.count; }
            private set { this.count = value; }
        }
        public void Add(object element)
        {
           
        }

Допишете метода Add(object element) който трябва да добави елемент в списъка. Обърнете внимание на това 
каква имплементация на списъчната структура е използвана!

 - public void Add(object element)
        {
            //ако броя на елементите ни е 0, т.е. ако няма елементи в списъка 
            if(count == 0)
            {
                //създаваме си един нов нод с елемента, който ни се подава
                Node newNode = new Node(element);
                //в такъв случай и началото и края ще са равни на този нов нод
                head = newNode;
                tail = newNode;
                //и броя на елементите ни се увеличава
                count++;
            }
            //в противен случай, ако вече имаме елементи в нашия списък
            else
            {
                //вече ще ползваме конструктора на класа Node на който подаваме елемента и опашката(предишния нод), или 
                //последния елемент в нашия списък
                Node newNode = new Node(element, tail);
                //казваме на последния елемент, че вече ще бъде равен на този нов нод
                tail = newNode;
                //и увеличаваме броя на елементите в нашия списък
                count++;
            }
        }

2. Даден е следния програмен фрагмент:

public class CustomArrayList
{
      private object[] arr; 
      private int count; 
      public int Count { get { return count; } }
 
      private static readonly int INITIAL_CAPACITY = 4;
 
      public CustomArrayList()
      {
            arr = new object[INITIAL_CAPACITY];
            count = 0;
      }
      public void Add(object item)
      {

      }

}

Допишете метода Add(object item) който трябва да добави елемент в списъка. Обърнете внимание, че първоначалния размер на масива може да бъде прехвърлен!

 - public void Add(T element)
        {
            if(this.Length == this.Capacity)
            {
                this.Capacity *= 2;
                T[] temp = new T[this.Capacity];
                for (int i = 0; i < items.Length; i++)
                {
                    temp[i] = items[i];
                }
                temp[this.Length] = element;
                items = temp;
                this.Length++;
            }
            else
            {
                items[this.Length] = element;
                this.Length++;
            }
        }

IV,V,VI,VII
1. Избройте три операции (методи), които можете да прилагате върху стек.
 - Push(T item)

Pop()

Peek()

2. Посочете вярното твърдение за държавната списъчна структура в .NET - Stack<T>

Използва динамична реализация [[2] - не].

Абстрактната структура, която изпълнява условието "първият влязъл първи излиза". [[2]- не]

Използва статичната реализация [[1] - да].

Абстрактна структура, която изпълнява  условието "последен влязъл – пръв излязъл" [[1] - да]

Можем да добавяме елементи най-отгоре и да извличаме последния добавен елемент. [[1] - да]

Добавените елементи се нареждат в края, а при извличане поредният елемент се взима от началото. [[2]- не]


3. Имате структура от данни, която има поведение от тип „последен влязъл, първи излиза“. Посочете правилно действието на всеки от методите:
 - Push() - добавя елемент най-горе в стека
 - Pop() - премахва най-горният елемент в стека
 - Peek() - връща най-горният елемент в стека, без да го премахва


4. Разработвате приложение, което използва структурата от данни Stack<T>. Пишете следния код:

Stack<int> processStack = new Stack<int>();

processStack.Push(50);

processStack.Push(45);

processStack.Pop();

processStack.Push(11);

processStack.Pop();

processStack.Push(7);

 

Какво ще бъде съдържанието на стека (stack), от горе на долу, след като се изпълнят изразите (инструкциите)?

- 7, 50

5. Посочете кой от следните примери показва добавяне на елемент към стек в C#, който е създаден по следния начин:

Stack s = new Stack();
 - s.Push(325);

6. Опишете какво прави методът Peek()?
 - връща най-горния елемент в стека, без да го премахва.

7. Опишете какво прави методът Pop()?
 - премахва най-горния елемент в стека

8. Опишете какво прави методът Push()?
 - Добавя елемент най-горе в стека


VIII.
1. Разработвате приложение, което оптимизира обработката на складови операции. Когато стоката пристигне, тя се 
разполага на стелажи. За да се намали времето за обработка на определен продукт, продуктите, които са доставени последни се обработват първи. Трябва да представите тези продукти в подходяща структура от данни. Каква списъчна структура от данни трябва да използвате в тази ситуация и обяснете защо?
 - В тази ситуация трябва да използваме списъчната структура от данни стек, защото поведението на елементите е от типа "първи влязъл - първи излиза". В случая, за да се намали времето за обработка на определен продукт, продуктите, които са доставени последни се обработват първи ни дава информацията, за структурата, която трябва да се използва в задачата.

2. Имате даден следния програмен фрагмент:
   public T Pop(int index)
        {
            if (this.Count == 0)
            {
                throw new InvalidOperationException("Empty stack")
            }
            this.Count--;
            T element = this.items[index];

            T[] temp = new T[this.items.Lenght];
            for (int i = 0; i < this.Count; i++)
            {
                temp[i] = this.items[i];
            }

            this.items = temp;
            return element;
        }
Този фрагмент е част от имплементацията на линейната структура от данни стек - премахване на елемент от стек. В кода има грешка! Вашата задача е да откриете грешката, да обясните каква е тя и по какъв начин ще я поправите!

- Грешката в кода е, че методът Pop(int index) получава цяло число, което вътре в метода се използва за намиране на елемента в масива и премахването на този елемент. По дефиниция линейната структура стек не работи така. Правилото за работа със стек е "първи влиза - първи излиза". Нямаме право да достъпваме елементите по индекс, освен само и единствено за четене.
Когато правим имплементацията за премахване на елемент от стек винаги премахваме последния елемент - в случая трябва да използваме броя на елементите (Count) на мястото на параметъра Index, за да премахнем последния елемент от масива в класа. И самия метод Pop() не трябва да приема параметър.


IX,X
1. Избройте три операции (методи), които можете да прилагате върху опашка.
 - Enqueue (T item)

Dequeue ()

Peek ()

2. Посочете вярното за следното твърдение:
[[1]] – добавя елемент в края на опашката
 - Enqueue

3. Посочете вярното твърдение за държавната списъчна структура в .NET - Queue<T>

Използва статичната реализация [[1] - ДА].

Абстрактната структура, която изпълнява условието "първият влязъл първи излиза". [[1] - ДА]

Използва динамична реализация [[2] - НЕ].

Абстрактна структура, която изпълнява  условието "последен влязъл – пръв излязъл" [[2] - НЕ]

Можем да добавяме елементи най-отгоре и да извличаме последния добавен елемент. [[2] - НЕ]

Добавените елементи се нареждат в края, а при извличане поредният елемент се взима от началото. [[1] - ДА]

4. Имате имплементация на свързана опашка. При така написания код, посочете верния изход в конзолата и броят на елементите в опашката.

var queue = new LinkedQueue<int>();

                queue.Enqueue(112);

                queue.Enqueue(911);

                queue.Enqueue(166);

                queue.Enqueue(160);

                queue.Enqueue(150);

                queue.Dequeue();



                Console.WriteLine(string.Join(" ", queue));

                Console.WriteLine("Count = {0}", queue.Count);

- 911, 166, 160, 150, Count = 4

5. Посочете кое от следните твърдения се отнася за опашка?
 - структура от данни, която има поведение от тип „първи влязъл, първи излиза“

6. Във Вашето приложение използвате опашна структура от данни, за да обработвате информацията. Трябва да намерите, дали даден елемент съществува в опашката, но все още не искате елемента да бъде обработван. Посочете коя от следващите операции за опашката ще използвате?
- contains

7. Посочете вярно или невярно - методът Engueue добавя елемент в стек.
 - Неистина


XI,XII
1. Разработвате ново приложение за оптимизиране на процесите в работата на призводствено предприятие. Трябва да приложите структура от данни, която да работи като „буфер“ срещу надхвърляне на капацитета. Когато сме в рамките на призводствения капацитет, артикулите в буфера 
трябва да се обработят в реда, в който се добавят. Обяснете коя структура от данни трябва да използвате защо бихте използвали точно нея, за да приложите такъв буфер?
- В опашката, артикулите се обработват в реда, в който са добавени. В частност, артикулите се добавят в края на опашката и се премахват от началото. Това е общоизвестно като first-in, first-out (FIFO) обработване.

2. Имате изброени методи за структура от данни, която има поведение от тип „първи влязъл, първи излязъл“. Свържете правилно всеки метод с неговото действие.
- Enqueue - добавя елемент в края на опашката
- Dequeue() - премахва и връща елемента от началото
- Peek() - връща елемента от началото без да го изтрива

3. Обяснете какво прави методът Dequeue()?
 - премахва и връща елемента от началото на опашката

4. Обяснете какво прави методът Enqueue(T)?
 - добавя елемент в края на опашката


XIII
1. Даден е следния програмен фрагмент:

 class CustomStack<T>
    {
        private class Node<T>
        {
            public T Value { get; set; }
            public Node<T> PrevNode { get; private set; }

            public Node(T value, Node<T> prev = null)
            {
                this.Value = value;
                this.PrevNode = prev;
            }
        }

        private Node<T> firstNode;
        public int Count { get; private set; }

        public void Push(T element)
        {
            
        }
}

Допишете метода Push(T element) който трябва да добави елемент в стека. Обърнете внимание на това каква имплементация на списъчната структура е използвана!

-  public void Push(T element)
        {
            this.firstNode = new Node<T>(element, this.firstNode);
            this.Count++;
        }

2. Даден е следния програмен фрагмент:

class CustomStack<T>
    {
        public const int INITIAL_CAPACITY = 16;

        private T[] items;
        public int Count { get; set; }

        public CustomStack(int initialCapacity = INITIAL_CAPACITY)
        {
            this.items = new T[initialCapacity];
        }

        public void Push(T element)
        {
        }        

Допишете метода Push(T element) който трябва да добави елемент в стека. Обърнете внимание на това каква имплементация на списъчната структура е използвана!

-   public void Push(T element)
        {
            if (this.Count == this.items.Length)
            {
                //this.Grow();
                T[] temp = new T[this.items.Length * 2];
                for (int i = 0; i < this.Count; i++)
                {
                    temp[i] = items[i];
                }

                this.items = temp;
            }

            this.items[this.Count] = element;
            this.Count++;

}

XIV.
1. Дефинирайте понятието алгоритъм.
 - Краен брой, еднозначно определени стъпки (команди), водещи до решаването на даден проблем

2. Дефинирайте понятието сложност на алгоритъм.
 - Сложност на алгоритъм е груба оценка на броя стъпки, които алгоритъмът ще направи в зависимост от размера на входните данни. Това е груба оценка, която се интересува от порядъка на броя стъпки, а не от точния им брой.

Формулирано още по-просто, сложност е груба, приблизителна оценка на броя стъпки за изпълнение на даден алгоритъм.

3. Посочете кои са по-важните свойства на алгоритмите?
 - всичко изброено


XV.
1. Дайте пример с C# код, за метод който да сортира  елементите от списъка List<int> list = new List<int>() { 12, 8, 10, 2, 9, 6, 1}; посредством алгоритъма за сортиране  чрез метода на мехурчето.
 - public static void BubbleSortWithFor(List<int> list)
        {
            for (int j = 0; j <= list.Count - 2; j++)
            {
                for (int i = 0; i <= list.Count - 2; i++)
                {
                    if (list[i] > list[i + 1])
                    {
                        Swap(list, i, i + 1);
                    }
                }
            }
        }
private static void Swap(List<int> list, int index, int min)
        {
            int temp = list[index];
            list[index] = list[min];
            list[min] = temp;
        }

2. Дайте пример с C# код, за метод който да сортира  елементите от списъка List<int> list = new List<int>() { 12, 8, 10, 2, 9, 6, 1}; посредством алгоритъма за сортиране  чрез вмъкване.
 - public static void InsertionSort(List<int> list)
        {
            for (int i = 1; i < list.Count; ++i)
            {
                int key = list[i];
                int j = i - 1;

                // Move elements of arr[0..i-1], 
                // that are greater than key, 
                // to one position ahead of 
                // their current position 
                while (j >= 0 && list[j] > key)
                {
                    list[j + 1] = list[j];
                    j = j - 1;
                }
                list[j + 1] = key;
            }
        }
private static void Swap(List<int> list, int index, int min)
        {
            int temp = list[index];
            list[index] = list[min];
            list[min] = temp;
        }

3. Дайте пример с C# код, за метод който да сортира  елементите от списъка List<int> list = new List<int>() { 12, 8, 10, 2, 9, 6, 1}; посредством алгоритъма за сортиране  чрез пряка селекция. 
 - public static void SelectionSort(List<int> list)
        {
            for (int index = 0; index < list.Count; index++)
            {
                int min = index;
                for (int current = index + 1; current < list.Count; current++)
                {
                    if(list[current] < list[min])
                    {
                        min = current;
                    }
                }

                Swap(list, index, min);
            }
            
        }

private static void Swap(List<int> list, int index, int min)

        {

            int temp = list[index];

            list[index] = list[min];

            list[min] = temp;

        }


XVI,XVII
1. Открийте липсващите части от кода:
 - public static int Linear<T>(T[] elements, T key) where T : IComparable
        {
            for (int index = 0; index < elements.length; index++)
            {
                if (elements[index] .CompareTo(key) == 0)
                {
                    return index;
                }
            }
            return -1;
        }

2. Изчислете максималния брой стъпки за намиране на сбора от четните елементи в масив. Като предполагаме, че една стъпка е една инструкция на CPU, а именно: подредби, търсения на елемент в масив, сравнения, аритметични операции.

int GetSumEven(int[] array)
{
  int sum = 0;
  for (int i = 0; i < array.Length; i++)
    if (array[i] % 2 == 0) 
        sum += array[i];
  return sum;
}

T(n) = (отговор);

 - 9n + 3


3. Имате даден следния код:

List<int> list = Console.ReadLine()
                .Split()
                .Select(int.Parse)
                .ToList();

            int currVal = list[0];
            int currCount = 1;
            int maxCount = 1;
            int maxValue = currVal;

            for (int i = 1; i < list.Count; i++)
            {
                if(currVal == list[i])
                {
                    currCount++;
                    if(currCount > maxCount)
                    {
                        maxCount = currCount;
                        maxValue = currVal;
                    }
                }
                else
                {
                    currCount = 1;
                    currVal = list[i];
                }
            }

            Console.WriteLine($"{maxValue} -> {maxCount}");

Свържете към намирането на коя от следните подредици съответства: [[1] - най-дълга подредица от равни числа]

4. Имате даден следния код:

List<int> list = Console.ReadLine()
                .Split()
                .Select(int.Parse)
                .ToList();
            int currValue = list[0];
            int maxValue = currValue;
            int currCount = 1;
            int maxCount = 1;
            int counter = 1;
            for (int i = 1; i < list.Count; i++)
            {
                if(currValue + counter == list[i])
                {
                    currCount++;
                    counter++;
                    if(currCount > maxCount)
                    {
                        maxCount = currCount;
                        maxValue = currValue;
                    }
                    
                }
                else
                {
                    currCount = 1;
                    currValue = list[i];
                    counter = 1;
                }

            }
            Console.WriteLine();
            Console.WriteLine(maxCount);

Свържете към намирането на коя от следните подредици съответства: [[2] - най-дълга подредица от нарастващи числа]

5. Имате даден следния код:

List<int> list = Console.ReadLine()
                .Split()
                .Select(int.Parse)
                .ToList();
            int currValue = list[0];
            int maxValue = currValue;
            int currCount = 1;
            int maxCount = 1;
            int counter = 1;
            for (int i = 1; i < list.Count; i++)
            {
                if (currValue - counter == list[i])
                {
                    currCount++;
                    counter++;
                    if (currCount > maxCount)
                    {
                        maxCount = currCount;
                        maxValue = currValue;
                    }

                }
                else
                {
                    currCount = 1;
                    currValue = list[i];
                    counter = 1;
                }

            }
            Console.WriteLine();
            Console.WriteLine(maxCount);

Свържете към намирането на коя от следните подредици съответства: [[3] - най-дълга подредица от намаляващи числа]

XVIII
1. Във вашата фирма постъпва проект за създаване на приложение, обслужващо „наказателен паркинг“.